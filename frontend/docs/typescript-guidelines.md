# TypeScript Guidelines

## Overview

This is a living document outlining guidelines for developing frontend projects using TypeScript within Kata.ai. At Kata.ai, we use [TypeScript](https://www.typescriptlang.org/) across our entire JavaScript stack. TypeScript combines the familiarity of JavaScript with the power of static typing.

In general, using static typing in your JavaScript code [can help prevent about 15%](https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/) of the bugs that end up in committed code. Not only static typing, TypeScript also provides various productivity enhancements like advanced statement completion, as well as smart code refactoring.

Our styleguide is mostly derived from the [Airbnb JavaScript styleguide](https://github.com/airbnb/javascript), with changes made to accomodate TypeScript projects.

## Table of Contents

- [Naming](#naming)
- [Indentation & Line length](#indentation--line-length)
- [Style](#style)
- [Types](#types)
- [Functions](#functions)
- [Classes](#classes)
- [Interfaces](#interfaces)
- [Enums](#enums)
- [Modules](#modules)

---

## Naming

### Keep filenames clear and concise

Use filenames that are as clear and standard as possible. Strive for names no longer than 2-3 words, with unabbreviated phrases.

- **Good example:** `findPathOptions.ts`
- **Bad example:** `fpOpts.ts`

### Test files

All test files must be written either separately inside a `__tests__/` folder, or within the same folder with a `.test.{js,ts,tsx}` suffix.

### Autogenerated files

All auto-generated files must be written either separately inside a `__generated__/` folder, or within the same folder with a `.generated.{js,ts,tsx}` suffix.

> Make sure to ignore these files in your TSLint/Prettier config.

## Indentation & Line length

### Use a 2-space indentation

Using space indentation ensures that indentation will look the same on all IDEs.

### Lines shouldn't exceed 120 characters

This is how long most modern screens could display monospace text inside any window without wrapping.

## Style

### Semicolons

Yes.

```ts
// Bad example
const maxThreshold = 25

// Good example
const maxThreshold = 25;
```

### Trailing comma

It is recommended to include a trailing comma in multiline array/object statements. This will lead to cleaner git diffs.

```js
// Bad example
const hero = {
  firstName: 'Ada',
  lastName: 'Lovelace',
  birthYear: 1815,
  superPower: 'computers'
};

// Good example
const hero = {
  firstName: 'Ada',
  lastName: 'Lovelace',
  birthYear: 1815,
  superPower: 'computers',
};
```

> Leaving the trailing comma on used to be a problem with legacy JavaScript, but ES6 no longer has that issue. Also, tools like Babel automatically removes the additional comma when compiling to older JavaScript.

## Types

### Avoid `any`

The whole point of TypeScript is to be more specific than this. So when you can, try to replace `any` with a more specific type declaration, or use `unknown` to force explicit type-checking of external types.

### Prefer `undefined` over `null`.

When dealing with code that uses `null` (e.g. in HTML selectors or Redux), these should be kept isolated using selectors.

### Use `// @ts-ignore` comment to ignore type errors

If a type error cannot be fixed for some reason, put a `// @ts-ignore` comment above the line with an explanation.

```ts
// @ts-ignore: doThing() api is changed on version 3.0 but the typings haven't been updated yet
const thing = doThing(one, two);
```

> Note that these should be treated as TODO items, since they're type errors that should be fixed next time there's a chance.

### Use PascalCase when declaring types.

```ts
// Bad example
type responseObject = {}

// Good example
type ResponseObject = {}
```

## Functions

### Declare function return type

If declaring a function, you should always specify the return type, even if it is nothing (i.e. `void`.)

```typescript
// Bad example
function healthCheck() {
  return fetch(apiUrl + '/healthCheck');
}

// Good example
function healthCheck(): Promise<HealthCheckResponse> {
  return fetch(apiUrl + '/healthCheck');
}
```

### Declare function argument type

The type of a function's arguments must be declared, even if it's `any`.

```ts
// Bad example
function add(a, b): number {
  return a + b;
}

// Good example
function add(a: number, b: number): number {
  return a + b
}
```

## Classes

### Declare access modifiers for each class property

You should always specify whether a class property is `public`, `private`, or `protected`.

```ts
class Button extends React.Component {
  constructor() {}

  // Bad example
  render(): JSX.Element {}

  // Good example
  public componentDidMount(): void {}
}
```

> React component lifecycles are generally classified as `public`, so use that whenever you come across one.

## Interfaces

### Use PascalCase when declaring interfaces.

```ts
// Bad example
interface checkoutButtonProps {}

// Good example
interface CheckoutButtonProps {}
```

### Don't use `I` as a prefix when declaring interfaces.

This convention is a leftover from early-day TS when people who mainly do C# started trying out TS, and is generally frowned upon nowadays, especially in frontend TS code.

We avoid prefixing interfaces with `I` specifically in the frontend.

```ts
// Bad example
interface ICheckoutButtonProps {}

// Good example
interface CheckoutButtonProps {}
```

## Enums

### Use PascalCase when declaring enums.

```ts
// Bad example
enum botStates {}

// Good example
enum BotStates {}
```

### Avoid `const` enums

Tools like Babel [don't support this syntax](https://babeljs.io/docs/en/babel-plugin-transform-typescript.html#caveats). Use regular enums instead, or just use a plain old JS object.

## Modules

### Prefer using named exports over default exports

All modules should use named exports where possible. It's easier to refactor our codebase that way.

The only exception to this rule is when a module is being code-split (e.g. a lazy-loaded React component).

### Prefer using a single entry point

When exporting modules from multiple files within the same folder, collect those exports inside an `index.js` file in the root level of that folder.

```
components/
└── Button/
    ├── index.ts
    ├── Button.tsx
    ├── LinkButton.tsx
    ├── HollowButton.tsx
    └── IconicButton.tsx
```

```ts
// ./components/Button/index.ts

export * from './Button';
export * from './LinkButton';
export * from './HollowButton';
export * from './IconicButton';
```
